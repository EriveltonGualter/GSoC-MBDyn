% $Header$
% MBDyn (C) is a multibody analysis code.
% http://www.mbdyn.org
%
% Copyright (C) 1996-2017
%
% Pierangelo Masarati  <masarati@aero.polimi.it>
%
% Dipartimento di Ingegneria Aerospaziale - Politecnico di Milano
% via La Masa, 34 - 20156 Milano, Italy
% http://www.aero.polimi.it
%
% Changing this copyright notice is forbidden.
%
% This program is free software; you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation (version 2 of the License).
% 
%
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
%
% You should have received a copy of the GNU General Public License
% along with this program; if not, write to the Free Software
% Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

\chapter{Modules}

\section{Element Modules}
Recall that element modules are invoked as \kw{user defined} elements,
whose syntax is
\begin{Verbatim}[commandchars=\\\{\}]
    \bnt{elem_type} ::= \kw{user defined}

    \bnt{normal_arglist} ::= \bnt{name} [ , \bnt{module_data} ]
\end{Verbatim}

\subsection{Module-aerodyn}
\emph{Authors: Fanzhong Meng and Pierangelo Masarati}

\noindent
This module implements NREL's AeroDyn v 12.58 wind turbine aerodynamic loads.

\subsection{Module-asynchronous\_machine}
\emph{Author: Reinhard Resch}

\noindent
This module implements an asynchronous electric motor.

\subsection{Module-cyclocopter}
\label{sec:MODULES:CYCLOCOPTER}
\emph{Author: Mattia Mattaboni (turned into module by Pierangelo Masarati)}

\noindent
This module implements inflow models for cycloidal rotors.

\begin{Verbatim}[commandchars=\\\{\}]
    \bnt{name} ::= \kw{cycloidal no inflow}

    \bnt{module_data} ::=
        \bnt{aircraft_node_label} ,
        [ \kw{orientation} , (\hty{OrientationMatrix}) \bnt{orientation} , ]
        \bnt{rotor_node_label}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
    \bnt{name} ::= \kw{cycloidal} \{ \kw{uniform 1D} | \kw{uniform 2D} | \kw{Polimi} \}

    \bnt{module_data} ::=
        \bnt{aircraft_node_label} ,
        [ \kw{orientation} , (\hty{OrientationMatrix}) \bnt{orientation} , ]
        \bnt{rotor_node_label}
        (\ty{bool}) \bnt{average} ,
        \bnt{rotor_radius} ,
        \bnt{blade_span}
        [ , \kw{delay} , (\hty{DriveCaller}) \bnt{delay} ]
        [ , \kw{omegacut} , \bnt{cut_frequency} ]
        [ , \kw{timestep} , \bnt{time_step} ]
\end{Verbatim}


The optional \kw{orientation} is required when axis 3 
of the aircraft node is not normal to the rotor axis, it is defined with respect to the aircraft node; axis 3
of the rotor node must be aligned with the rotor axis; the choices of axes 1 and 2 only influence the orientation of the output.

\paragraph{Example 1.} \
\begin{verbatim}
user defined: CURR_DRUM,
    cyclocopter no inflow,
    AIRCRAFT,
    orientation,
        reference, node,
            1, 0., 0., 1.,
            3, 0., 1., 0.,
    AIRCRAFT;
\end{verbatim}
The latter defines a cyclocopter with no inflow. It essentially is only useful to obtain the output data.

\paragraph{Example 2.} \
\begin{verbatim}
user defined: CURR_DRUM,
    cyclocopter uniform 2D,
    AIRCRAFT,
    orientation,
        reference, node,
    	    1, 0., 0., 1.,
    	    3, 0., 1., 0.,
    CURR_DRUM,
    0, # no average
    # 1, # average
    ROTOR_DIAMETER/2.,
    SPAN,
    delay,
        const, 0.5,
    omegacut, OMEGA_CUT,
    kappa, 1.3, # hover empirical correction coefficient
    timestep, DT,
    output, yes;	
\end{verbatim}
While this one defines a cyclocopter with a twodimensional inflow model.


\subsubsection{Output}
The output is obtained in plain text in the \textbf{.usr} file where the columns represent,
\begin{itemize}
\item 1: element label
\item 2--4: rotor force on the aircraft in local $x$, $y$ and $z$ directions in the optionally transformed, if \bnt{orientation} is defined, aircraft reference frame  %RRotorTranspose*Res.Force()
\item 5--7: rotor moment about the aircraft in local $x$, $y$ and $z$ directions in the optionally transformed, if \bnt{orientation} is defined, aircraft reference frame % RRotorTranspose*Res.Moment()
\item 8:  mean magnitude of the inflow velocity, based on momentum theory % dUindMean
\item 9--16: depends on inflow model
\end{itemize}


%~ CyclocopterUniform1D::Output(OutputHandler& OH) const
%~ 
                        %~ << " " << dAzimuth                	 /* 9 */
                        %~ << " " << iStepCounter                	 /* 10 */
                        %~ << " " << "0."                	 /* 11 */
                        %~ << " " << "0."                	 /* 12 */
                        %~ << " " << "0."                	 /* 13 */
                        %~ << " " << FMeanOut                	 /* 14 */
                        %~ << std::endl;
%~ 
%~ CyclocopterUniform2D::Output(OutputHandler& OH) const
%~ 
                        %~ << " " << dAzimuth                	 /* 9 */
                        %~ << " " << iStepCounter                	 /* 10 */
                        %~ << " " << dUind                	 /* 11-13 */
                        %~ << " " << FMeanOut                	 /* 14-16 */
                        %~ << std::endl;
                        %~ 
%~ 
%~ CyclocopterPolimi::Output(OutputHandler& OH) const
%~ 
                        %~ << " " << dUind                	 /* 9 -11*/
                        %~ << " " << dXi                	 /* 12 */
                        %~ << " " << dAzimuth               /* 13 */
                        %~ << " " << FMeanOut                	 /* 14-16 */
                        %~ << std::endl;


\subsection{Module-fab-electric}
\emph{Author: Eduardo Okabe}

\noindent
This module implements several electric components.

\subsubsection{Resistor}
\begin{Verbatim}[commandchars=\\\{\}]
    \bnt{name} ::= \kw{resistor}
\end{Verbatim}

\subsubsection{Capacitor}
\begin{Verbatim}[commandchars=\\\{\}]
    \bnt{name} ::= \kw{capacitor}
\end{Verbatim}

\subsubsection{Inductor}
\begin{Verbatim}[commandchars=\\\{\}]
    \bnt{name} ::= \kw{inductor}
\end{Verbatim}

\subsubsection{Diode}
\begin{Verbatim}[commandchars=\\\{\}]
    \bnt{name} ::= \kw{diode}
\end{Verbatim}

\subsubsection{Switch}
\begin{Verbatim}[commandchars=\\\{\}]
    \bnt{name} ::= \kw{switch}
\end{Verbatim}

\subsubsection{Electrical source}
\begin{Verbatim}[commandchars=\\\{\}]
    \bnt{name} ::= \kw{electrical source}
\end{Verbatim}

\subsubsection{Ideal transformer}
\begin{Verbatim}[commandchars=\\\{\}]
    \bnt{name} ::= \kw{ideal transformer}
\end{Verbatim}

\subsubsection{Operational amplifier}
\begin{Verbatim}[commandchars=\\\{\}]
    \bnt{name} ::= \kw{operational amplifier}
\end{Verbatim}

\subsubsection{BJT}
\begin{Verbatim}[commandchars=\\\{\}]
    \bnt{name} ::= \kw{bjt}
\end{Verbatim}

\subsubsection{Proximity sensor}
\begin{Verbatim}[commandchars=\\\{\}]
    \bnt{name} ::= \kw{proximity sensor}
\end{Verbatim}



\subsection{Module-fab-motion}
\emph{Author: Eduardo Okabe}

\noindent
This module implements several joints.

\subsubsection{Gear joint}
\begin{Verbatim}[commandchars=\\\{\}]
    \bnt{name} ::= \kw{gear joint}
\end{Verbatim}

\subsubsection{Linear transmission joint}
\begin{Verbatim}[commandchars=\\\{\}]
    \bnt{name} ::= \kw{linear transmission joint}
\end{Verbatim}

\subsubsection{Motion transmission joint}
\begin{Verbatim}[commandchars=\\\{\}]
    \bnt{name} ::= \kw{motion transmission joint}
\end{Verbatim}

\subsubsection{Smooth step}
\begin{Verbatim}[commandchars=\\\{\}]
    \bnt{name} ::= \kw{smooth step}
\end{Verbatim}



\subsection{Module-fab-sbearings}
\emph{Author: Eduardo Okabe}

\noindent
This module implements several joints.

\subsubsection{Hydrodynamic bearing}
\begin{Verbatim}[commandchars=\\\{\}]
    \bnt{name} ::= \kw{hydrodynamic bearing}
\end{Verbatim}

\subsubsection{Rolling bearing}
\begin{Verbatim}[commandchars=\\\{\}]
    \bnt{name} ::= \kw{rolling bearing}
\end{Verbatim}



\subsection{Module-hfelem}
\input{module-hfelem}



\subsection{Module-hydrodynamic\_plain\_bearing\_with\_offset}
\emph{Author: Reinhard Resch}

%\noindent
%This module implements a lubricated bearing.

\input{module-hydrodynamic_plain_bearing}

\subsection{Module-imu}
\emph{Author: Pierangelo Masarati}

\noindent
This module implements an element that provides the motion of a structural node
in the form of the output of an Inertial Measurement Unit
(3 components of acceleration, 3 components of angular velocity in body axes)
and an element that prescribes the motion of a structural node
in terms of acceleration and angular velocity.

\subsubsection{IMU}
This user-defined element emulates a IMU.
\begin{Verbatim}[commandchars=\\\{\}]
    \bnt{name} ::= \kw{imu}

    \bnt{module_data} ::=
        \bnt{node_label}
            [ , \kw{position} , (\hty{Vec3}) \bnt{offset} ]
            [ , \kw{orientation} , \hty{OrientationMatrix} \bnt{orientation} ]
\end{Verbatim}
It makes the acceleration and the angular velocity of node \nt{node\_label}
available in the node's reference frame as private data.
The location and orientation of the IMU with respect to the node may be modified
by \nt{offset} and \nt{orientation}.

\paragraph{Output.}
This element sends output to the \texttt{.usr} file.
Each entry contains
\begin{itemize}
\item[1)] the label
\item[2--4)] three components of angular velocity, in the reference frame of the node
\item[5--7)] three components of acceleration, in the reference frame of the node
\end{itemize}

\paragraph{Private Data.}
The following data are available:
\begin{enumerate}
\item \kw{"wx"} angular velocity in local direction 1
\item \kw{"wy"} angular velocity in local direction 2
\item \kw{"wz"} angular velocity in local direction 3
\item \kw{"ax"} acceleration in local direction 1
\item \kw{"ay"} acceleration in local direction 2
\item \kw{"az"} acceleration in local direction 3
\end{enumerate}


\subsubsection{IMU constraint}
This user-defined element enforces IMU data as a constraint.
\begin{Verbatim}[commandchars=\\\{\}]
    \bnt{name} ::= \kw{imu constraint}

    \bnt{module_data} ::=
        \bnt{node_label}
            [ , \kw{position} , (\hty{Vec3}) \bnt{offset} ]
            [ , \kw{orientation} , (\hty{OrientationMatrix}) \bnt{orientation} ]
            (\htybty{TplDriveCaller}{Vec3}) \bnt{omega} ,
            (\htybty{TplDriveCaller}{Vec3}) \bnt{acceleration}
\end{Verbatim}
It imposes the angular velocity \nt{omega} and the acceleration \nt{acceleration},
namely the measurements that come from an IMU, to node \nt{node\_label}.
The location and orientation of the IMU with respect to the node may be modified
by \nt{offset} and \nt{orientation}.

\paragraph{Output.}
This element sends output to the \texttt{.usr} file.
Each entry contains
\begin{itemize}
\item[1)] the label
\item[2--4)] three angular velocity Lagrange multipliers, in the reference frame of the node
\item[5--7)] three acceleration Lagrange multipliers, in the reference frame of the node
\item[8--10)] three components of velocity, in the reference frame of the node
\item[11--13)] three components of velocity derivative, in the reference frame of the node
\end{itemize}





\subsection{Module-mds}
This module is a simple example of run-time loadable user-defined element,
implements a scalar mass-damper-spring system.

\subsection{Module-nonsmooth-node}
\emph{Author: Matteo Fancello}
\begin{Verbatim}[commandchars=\\\{\}]
    \bnt{name} ::= \kw{nonsmooth node}

    \bnt{module_data} ::=
        (\ty{StructDispNode}) \bnt{NonsmoothNODELABEL} ,
        \kw{mass} , (\ty{real}) \bnt{mass} ,
        \kw{radius} , (\ty{real}) \bnt{radius} ,
        \kw{planes} , (\ty{integer}) \bnt{number_of_planes} ,
            \bnt{PlaneDefiningNODELABEL} ,
                \kw{position} , (\hty{Vec3}) \bnt{relative_plane_position} ,
                \kw{rotation orientation} , (\hty{OrientationMatrix}) \bnt{rel_rot_orientation_1} ,
                \kw{restitution} , (\ty{real}) \bnt{rest_coef}
                [ , \kw{friction coefficient} , (\ty{real}) \bnt{mu} ] 
            [ , ... ] # as many blocks as \nt{number_of_planes}
        [ , \kw{constraint type} , \{ \kw{position} | \kw{velocity} | \kw{both} \} ] # default: \kw{both}
        [ , \kw{theta} , \bnt{theta} ]
        [ , \kw{gamma} , \bnt{gamma} ]
        [ , \kw{LCP solver} , \bnt{solver} ]
        [ , \kw{tolerance} , \bnt{tolerance} ]
        [ , \kw{max iterations} , \bnt{num_iter} ]
            # these options depend on LCP solver support, see
            # \url{http://siconos.gforge.inria.fr/Numerics/LCPSolvers.html}
        [ , \kw{limit iterations} , \bnt{niterations} ]
        [ , \kw{limit LCP iterations} , \bnt{niterations} ]
        [ , \kw{verbose} , \{ \kw{yes} | \kw{no} | (\ty{bool}) \bnt{verbose} \} ]

    \bnt{solver} ::=
        \kw{lexico lemke} # the default
        | \kw{rpgs}
        | \kw{qp}
        | \kw{cpg}
        | \kw{pgs}
        | \kw{psor}
        | \kw{nsqp}
        | \kw{latin}
        | \kw{latin_w}
        | \kw{newton_min}
        | \kw{newton_FB}
\end{Verbatim}

\subsubsection{Output}
\begin{itemize}
\item 1: element label
\item 2--4:   impulse on nonsmooth node in global ref. frame
\item 5--7:   position of nonsmooth node in global ref. frame
\item 8--10:  velocity of nonsmooth node in global ref. frame
\item 11--13: constraint reaction between multibody node and nonsmooth node
\item 14:    norm of the impulse reaction normal to the contact plane
\item 15:    number of active constraints during step
\end{itemize}
if verbose, also:
\begin{itemize}
\item 16--18: position constraint relaxation factor
	(only when \kw{constraint type} is \kw{both})
\item 19:    LCP solver status:
	0 indicates convergence,
	1 indicates \nt{iter} $\equiv$ \nt{maxiter},
	$>1$ indicates failure
(only for some solvers)
\item 20:    LCP solver \nt{resulting\_error}
(only meaningful for some solvers)
\end{itemize}


\subsection{Module-template2}
Template of user-defined element.

\subsection{Module-wheel2}
\emph{Authors: Marco Morandini, Stefania Gualdi and Pierangelo Masarati}

\noindent
This module implements a simple tire model for aircraft landing and ground handling.


\subsection{Module-wheel4}
%% written on April 2015
\emph{Authors: Louis Gagnon, Marco Morandini, and Pierangelo Masarati}

\noindent
This module implements a rigid ring tire model similar to the models commonly known as SWIFT. It is used as an element that will apply a 3D force and a 3D moment to the ring node of a wheel-ring multibody system. A wheel node is also necessary for inertia and contact forces calculations. It is intended to evaluate the transient behavior of the tire rolling on a deteriorated road profile. The equations are integrated implicitly except for the road profile, which is an input. This profile has to be previously filtered by a super ellipse function because the wheel4 module will only apply the tandem-cam part of the profile filtering. It is tailored for, but not restricted to, applications at low camber angles, limited steering and velocity changes, and continuous contact with the road. It is expected to be accurate under excitation frequencies up to 100~Hz and road deformations up to 20\% of the tire radius. A variable time-step algorithm is also embed and speeds up the simulation in cases where the road is flat.

Two runnable examples are available and will clarify the implementation in an actual multibody simulation:
\begin{itemize}
\item the simple example \textit{axleExampleNoData} located within the module-wheel4 directory of the MBDyn package
\item the more complex \textit{semitrailer} model is available on the example page of the MBDyn website; this example provides the script necessary to apply the super ellipse filter on the road profile; \htmladdnormallink{\kw{http://www.mbdyn.org/?Documentation\_\_\_Official\_Documentation\_\_\_Examples}}{http://www.mbdyn.org/?Documentation\_\_\_Official\_Documentation\_\_\_Examples}
\end{itemize}

\begin{Verbatim}[commandchars=\\\{\}]
    \bnt{name} ::= \kw{wheel4}

    \bnt{module_data} ::=
        (\ty{StructDispNode}) \bnt{WheelStructNodeLabel} , (\ty{StructBody}) \bnt{WheelBodyLabel} ,
        (\ty{OrientationVector}) \bnt{wheel_axle_direction} , (\ty{real}) \bnt{tire_radius} ,
        \kw{swift} ,
        (\ty{StructDispNode}) \bnt{RingStructNodeLabel} , (\ty{StructBody}) \bnt{RingBodyLabel} ,
        (\ty{vector}) \bnt{patch_stiffness} , (\ty{drive}) \bnt{stiffness_modifier} ,
        (\ty{vector}) \bnt{patch_damping} , (\ty{drive}) \bnt{damping_modifier} ,
        (\ty{vector}) \bnt{initial_patch_velocity} , (\ty{real}) \bnt{patch_mass} ,
        (\hty{DriveCaller}) \bnt{road_profile_driver} ,
        (\ty{real}) \bnt{patch_to_ellip_cam_ratio} ,
        (\ty{real}) \bnt{r_a1_param} , (\ty{real}) \bnt{r_a2_param} ,
        (\ty{real}) \bnt{patchToTireCircumf_ratio} ,
        (\ty{real}) \bnt{vert_wheel_ring_stiff}
        [ , \kw{loadedRadius} ]
        [ , \kw{slip} ,
        \kw{ginac} , \bnt{longi_tire_force_funct} ,
        \kw{ginac} , \bnt{lateral_tire_force_funct} ,
        \kw{ginac} , \bnt{pneumatic_trail_funct} ,
        \kw{ginac} , \bnt{aligning_residual_moment} ,
        (\ty{real}) \bnt{S_ht} , (\ty{real}) \bnt{S_hf} ,
        (\ty{real}) \bnt{q_sy1} , (\ty{real}) \bnt{q_sy3} ,
        (\ty{real}) \bnt{dvao}
        [ , \kw{threshold}, (\ty{real}) \bnt{TRH} , (\ty{real}) \bnt{TRHA} , (\ty{real}) \bnt{TRHT} , 
        (\ty{real}) \bnt{TRHTA} , (\ty{real}) \bnt{TRHC} , (\ty{real}) \bnt{TdLs} , (\ty{real}) \bnt{TdReDiv} ,
        (\ty{real}) \bnt{TdRe} , (\ty{real}) \bnt{dtOn} , (\ty{real}) \bnt{TmaxH} , 
        (\ty{real}) \bnt{dtRes} , (\ty{real}) \bnt{maxstep} , (\ty{real}) \bnt{minstep} , 
        (\ty{real}) \bnt{TmaxF} , (\ty{real}) \bnt{TminF} , (\ty{integer}) \bnt{TminS} , (\ty{real}) \bnt{TdivF} ,
        (\ty{real}) \bnt{TdivF3} , (\ty{real}) \bnt{TdivF4} , (\ty{real}) \bnt{RDA} , 
        (\ty{real}) \bnt{RDB} , (\ty{real}) \bnt{RDL} ] ]
\end{Verbatim}
where the keyword \kw{loadedRadius} enables the use of the alternative, validated, loading radius instead of the more generally used definition. The keywords \kw{slip} and \kw{threshold} should always be present. Although the given examples are the best way to understand the model, the following tables clarify most input parameters,

%theoretically allows turning off the contact forces, the code has never been adjusted to work that way and thus the keyword 
%A similar reasoning applies to the  keyword, which enables the threshold parameters that stabilize the tire model. 

\begin{tabular}{p{0.3\textwidth}p{0.7\textwidth}}
	\hline
		  & \textbf{tire parameters} \\
        \bnt{wheel\_axle\_direction}      & 3D vector of the wheel axle direction in the absolute reference frame (care should be taken if set to a value other than \textit{0.,1.,0.} because no elaborate testing has been carried for alternate axle initial orientations; any comments or on its functionality are welcome) \\
	\bnt{tire\_radius}	               &   rigid ring radius (undeformed radius of the tire) \\
	\bnt{patch\_stiffness}                  & 3D stiffness vector of the contact patch to ring connection (in the ring reference frame) \\
	\bnt{stiffness\_modifier}     & modifier drive to allow, for example, a gradual application of the stiffness   \\
	\bnt{patch\_damping}          & 3D damping vector of the contact patch to ring connection (usually about 6\% to 10\% of critical damping and distributed over ring and patch connections)   \\
	\bnt{damping\_modifier}       & modifier drive to allow, for example, a gradual application of the damping   \\ 
	 \bnt{initial\_patch\_velocity}          & 3D vector for the initial velocity of the patch in absolute reference frame \\
        \bnt{patch\_to\_ellip\_cam\_ratio}          &  patch contact-length to elliptical cam tandem base parameter (Schmeitz eq. 4.15, $l_s/(2a)$ )  \\
	\bnt{r\_a1\_param} 	        &  $r_{a1}$ contact length parameter from Besselink eq. 4.85 \\
	\bnt{r\_a2\_param} 	        & $r_{a2}$ contact length parameter from Besselink eq. 4.85  \\
	\bnt{patchToTireCircumf\_ratio} & ratio of the contact patch length to tire circumference (to calculate how much mass contributes to the ring's centripetal forces)  \\	  
	\bnt{vert\_wheel\_ring\_stiff}     & vertical stiffness given to the viscoelastic connection between the ring and the wheel nodes      \\ 
	\bnt{longi\_tire\_force\_func}       & longitudinal force $F_x/F_z$ given in GiNaC format \\
        \bnt{lateral\_tire\_force\_func}            & lateral force $F_y/F_z$ given in GiNaC format \\
        \bnt{pneumatic\_trail\_func}               & pneumatic trail divided by vertical force and given in GiNaC format  \\
        \bnt{aligning\_residual\_moment}      & residual torque $M_{zr}/F_z$  given in GiNaC format   \\
	\bnt{S\_ht}      & horizontal shift of pneumatic trail, for aligning moment angle modifier \\
	\bnt{S\_hf}   & residual aligning moment angle modifier/shift \\
	\bnt{q\_sy1}   & tire rolling resistance linear velocity coefficient (usually between 0.01 and 0.02) \\
	\bnt{q\_sy3}  & rolling resistance velocity correction coefficient \\
	\bnt{dvao} & reference velocity for rolling resistance velocity influence factor \\
	\hline
\end{tabular}

\begin{tabular}{p{0.3\textwidth}p{0.7\textwidth}}
\hline
	           & \textbf{variable timestep algorithm parameter} \\
	\bnt{dtOn} & boolean to enable or disable adjustable timestep calculation (will greatly increase the rapidity of the solution only if you have few bumps on a very smooth road and will otherwise slow down the simulation) \\
	\bnt{TmaxH} & maximum height change wanted on the road profile for one step \\
	\bnt{dtRes} & resolution of bump search  \\
	\bnt{maxstep} & maximum timestep imposed in the initial value section \\
	\bnt{minstep} &  minimum timestep imposed in the initial value section \\
	\bnt{TdivF3} &  timestep adjustment factor if force switched sign 3 times in the last \kw{TminS} steps\\
	\bnt{TdivF4} &  timestep adjustment factor if force switched sign 4 or more times in the last \kw{TminS} steps\\
	\hline
\end{tabular}
	
\begin{tabular}{p{0.3\textwidth}p{0.7\textwidth}}
\hline
	           & \textbf{road offset parameters} \\
	\bnt{RDA} & road offset (null before position reaches that value) \\
	\bnt{RDB} & road offset (interpolated when position is between \bnt{RDA} and that value) \\
	\bnt{RDL} & road loop condition (will loop after \bnt{RDB}+\bnt{RDL} over \bnt{RDL}) \\
	\hline
\end{tabular}
	
\begin{tabular}{p{0.3\textwidth}p{0.7\textwidth}}
\hline
	           & \textbf{algorithm threshold parameters} \\
	\bnt{TRH} &   prevents division by zero at null x-velocity at the price of losing validity for velocities near \bnt{TRH} \\
	\bnt{TRHA} & buffer used to prevent division by zero \\
	\bnt{TRHT} & prevents division by zero when computing the angle of the vehicle or wheels \\
	\bnt{TRHTA} & buffer used on angle zero division prevention \\
	\bnt{TRHC} & maximum value allowed for the longitudinal slip ratio \\
	\bnt{TdLs} & minimum value that the half contact patch length may take \\
	\bnt{TdReDiv} & minimum value that the wheel angular velocity may take in the calculation of the effective rolling radius \\
	\bnt{TdRe} & maximum ratio $\left|\frac{effective rolling radius}{ring radius}\right|$ which will be allowed to reach \\
	\hline
\end{tabular}
\newline

Information about the informally cited works may be found in the following two theses,
\begin{itemize}
\item Schmeitz, A. J. C. (2004) \textit{A Semi-Empirical Three-Dimensional Model of the Pneumatic Tyre Rolling over Arbitrarily Uneven Road Surfaces} available on request
\item Besselink, I.J.M. (2000). \textit{Shimmy of Aircraft Main Landing Gears} available at
\newline
\htmladdnormallink{\kw{http://www.tue.nl/en/publication/ep/p/d/ep-uid/227775/}}{http://www.tue.nl/en/publication/ep/p/d/ep-uid/227775/}
\end{itemize}

\subsubsection{Output}
The output can be obtained either in plain text in the \textbf{.usr} file or in NetCDF format in the \textbf{.nc} file. Section~\ref{sec:NetCDF:Node:Structural Node} explains the NetCDF output whereas the plain text output is as follows,
\begin{itemize}
\item 1: element label
\item 2: velocity of wheel in x-dir (longitudinal, forward)
\item 3: velocity of wheel in y-dir (lateral)
\item 4: relative speed between center of wheel and contact point on tire in the forward direction
\item 5--7: moment applied on ring by this module
\item 8--10: moment arm on ring
\item 11: slip ratio
\item 12: slip angle
\item 13: longitudinal friction coefficient
\item 14: lateral friction coefficient
\item 15: road height
\item 16--18: road normal
\item 19--21: position of patch
\item 22--24: velocity of patch
\item 25--27: relative position of patch
\item 28--30: relative velocity of patch
\item 31--33: force between ring and patch acting on patch
\item 34--36: force between ring and patch acting on ring and thus applied on ring by this module
\item 37--39: forward direction vector of the wheel
\item 40--42: forward direction vector of the ring
\item 43--45: forward direction vector of the ring without the slope of the profile
\item 46--48: point of contact on ring between ring and springs (contact patch viscoelastic elements)
\item 49: normal force for Pacejka's formulas
\item 50--52: relative velocity between patch and wheel
\item 53: sum of wheel, ring, and patch kinetic energies
\item 54: sum of wheel and ring potential energies (patch is not included because it is not subjected to gravity)
\item 55: sum of wheel, ring, and patch total energies (kinetic + potential)
\item 56: virtually calculated effective rolling radius
\item 57: half length of the tandem elliptical cam follower
\item 58: modified loaded radius (distance between ring center and patch center)
\item 59--61: distance between ring contact point and patch as seen from the ring in its own reference frame (not rotated with road slope)
\item 62: centrifugal force added to tire
\item 63--65: rolling resistance force vector (this force is then applied as a moment only)
\item 66--68: aligning moment
\item 69: center point x-value of the road profile (this is not actual position, but only position on the input road file
\item 70: front edge x-point of the tandem (front contact point of patch)
\item 71: rear edge x-point of the tandem (rear contact point of patch)
\item 72: centrifugally induced virtual displacement of tire in the radial direction (units of distance)
\item 73: patch vertical velocity calculated using road displacement and timestep
\item 74: timestep
\end{itemize}



\section{Constitutive Law Modules}

\subsection{Module-constlaw}
Simple example of run-time loadable user-defined constitutive law.

\subsection{Module-constlaw-f90}
Simple example of run-time loadable user-defined constitutive law in Fortran 90.

\subsection{Module-constlaw-f95}
Simple example of run-time loadable user-defined constitutive law in Fortran 95.

\subsection{Module-cont-contact}
\emph{Author: Matteo Fancello}

\noindent
Implements various formulas of 1D continuous contact models.
The same constitutive law can also be used as a 3D constitutive law,
under the assumption that the 1D formulas are considered with respect
to direction 3 of the 3D entity it is associated with.
In such case, the component 3 of strain and strain rate are used as inputs,
and the output force is applied along direction 3.

The syntax is
\begin{Verbatim}[commandchars=\\\{\}]
    \bnt{drive_caller} ::= \kw{help} ;
        | [ \kw{help} , ]
            [ \kw{sign} , \{ \kw{positive} | \kw{negative} | \bnt{sign_value} \} , ]
            [ \kw{formulation} , \{ \kw{flores} | \kw{hunt crossley} | \kw{lankarani nikravesh} \} , ]
            \kw{restitution} , \bnt{restitution_coef} ,
            \kw{kappa} , \bnt{stiffness} ,
            \kw{exp} , \bnt{exponent}
            [ , \kw{EpsPrimeTol} , \bnt{initial_eps_prime_tol} ]
\end{Verbatim}
\begin{itemize}
\item \bnt{sign\_value} is a non-null real number, whose sign is used for the \kw{sign} parameter.
\item \bnt{restitution\_coef} is the restitution coefficient ($[0 \to 1]$).
\item \bnt{stiffness} is the stiffness coefficient ($ > 0$).
\item \bnt{exp} is the exponent ($ > 1$).
\item \bnt{initial\_eps\_prime\_tol} is the tolerance on the initial contact velocity ($ > 0$).
\end{itemize}

Three models are implemented. They all use the strain and the strain rate, either as are, when \kw{sign} is \kw{positive},
or their opposite, when \kw{sign} is \kw{negative},
\begin{subequations}
\begin{align}
	x &= \nt{sign\_value} \cdot \nt{Eps}
	\\
	\dot{x} &= \nt{sign\_value} \cdot \nt{EpsPrime}
\end{align}
\end{subequations}
The expression of the force is
\begin{subequations}
\begin{align}
	f &= 0 && \text{$x \le 0$}
	\\
	f &= \nt{sign\_value} \cdot  x^{\nt{exp}} \plbr{ \nt{stiffness} + \nt{dissipation\_coef} \cdot \dot{x}} && \text{$x > 0$}
\end{align}
\end{subequations}
with the dissipation coefficient \nt{dissipation\_coef} defined according to each of the supported models.

Their \kw{formulation} is:
\begin{itemize}
\item \kw{flores} \cite{FLORES-2011-MUBO}: this is the default model; the dissipation coefficient is
\begin{align}
	\nt{dissipation\_coef} &= \frac{8}{5} \cdot \nt{stiffness} \cdot \frac{1 - \nt{restitution\_coef}}{\nt{restitution\_coef} \cdot \dot{x}_0}
\end{align}
Note that in this case $0 < \nt{restitution\_coef} \le 1$.

\item \kw{hunt crossley} \cite{HUNT-1975}: the dissipation coefficient is
\begin{align}
	\nt{dissipation\_coef} &= \frac{3}{2} \cdot \nt{stiffness} \cdot \frac{1 - \nt{restitution\_coef}}{\dot{x}_0}
\end{align}

\item \kw{lankarani nikravesh} \cite{LANKARANI-1994-ND}: the dissipation coefficient is
\begin{align}
	\nt{dissipation\_coef} &= \frac{3}{4} \cdot \nt{stiffness} \cdot \frac{1 - \nt{restitution\_coef}^2}{\dot{x}_0}
\end{align}
\end{itemize}
Note that $\nt{dissipation\_coef} = 0$ when $|\dot{x}_0| < \nt{initial\_eps\_prime\_tol}$;
i.e., when the initial contact velocity is below the threshold, no dissipation takes place.


\subsection{Module-damper-graall}
\emph{Author: Pierangelo Masarati, based on an original work of Gian Luca Ghiringhelli}

This module implements a 1D constitutive law that models
the behavior of a landing gear shock absorber.
It requires the user to supply the name of the GRAALL-style 
input file that contains the data of the damper.
It will be documented as soon as it reaches an appreciable level
of stability.
See also the 
\htmlref{\kw{shock absorber}}{sec:CL:SHOCK-ABSORBER}
constitutive law.

\subsection{Module-damper-hydraulic}
\emph{Author: Pierangelo Masarati}

\noindent
This module implements a simple hydraulic damper with turbulent orifice and relief valve.

\subsection{Module-muscles}
\emph{Authors: Andrea Zanoni and Pierangelo Masarati}

\bigskip

\noindent
This module implements a family of simple muscle constitutive laws,
based on \cite{PENNESTRI-2007-JB}.
\begin{Verbatim}[commandchars=\\\{\}]
    \bnt{drive_caller} ::= \kw{muscle Pennestri} ,
        [ \kw{initial length} , \bnt{Li} , ]
        \kw{reference length} , \bnt{L0} ,
        [ \kw{reference velocity} , \bnt{V0} , ]
        \kw{reference force} , \bnt{F0} ,
        \kw{activation} , (\hty{DriveCaller}) \bnt{activation}
            [ , \kw{activation check} , (\ty{bool}) \bnt{activation_check} ]
        [ , \kw{ergonomy} , \{ \kw{yes} | \kw{no} \} ]
        [ , \kw{reflexive} , # only when ergonomy == no
            \kw{proportional gain} , \bnt{kp} ,
            \kw{derivative gain} , \bnt{kd} ,
            \kw{reference length} , (\hty{DriveCaller}) \bnt{lref} ]
\end{Verbatim}
The \kw{ergonomy} flag, when active, indicates that the equivalent damping
must not be used.
It is used to indicate that the constitutive law acts as an ``ergonomy''
spring in an inverse kinematics analysis.

The \kw{reflexive} keyword indicates that reflexive behavior is being defined;
its use is mutually exclusive with the active status of the \kw{ergonomy} flag.

The \kw{initial length} equal to \kw{reference length} unless specified.
It is used to differentiate the length of the rod as computed from the input
from the length used to formulate the constitutive law.

The \kw{reference velocity} is set to 2.5 m/s unless specified.

The second occurrence of the \kw{reference length} is related
to the reflexive contribution to muscular activation, which is defined as
\begin{align}
	a
	&=
	\nt{activation}
	+
	\nt{kp} \cdot \plbr{
		\frac{\ell}{\nt{L0}}
		-
		\frac{\nt{lref}}{\nt{L0}}
	}
	+
	\nt{kd} \cdot \frac{\dot{\ell}}{\nt{V0}}
\end{align}

\paragraph{Output.}
The module appends additional output to the row of the element it is
attached to in the \texttt{.jnt} file. Two columns are added:
\begin{itemize}
  \item \kw{a}: the actual total activation of the muscle;
  \item \kw{aReq}: the \emph{requested} activation of the muscle, before
    saturation is applied to confine it in the $0 < a < 1$ range. 
\end{itemize}
The two parameters are also added to the NetCDF output of the element.

\section{Drive Caller Modules}

\subsection{Module-drive}
Simple example of run-time loadable user-defined drive caller.


\subsection{Module-randdrive}
Generates normally distributed pseudo-random numbers
with given mean and variance (standard deviation) using 
the random number handling capabilities
provided by Boost\footnote{\url{http://www.boost.org/}}.
\begin{Verbatim}[commandchars=\\\{\}]
    \bnt{drive_caller} ::= \kw{boost random} ,
        (\ty{real}) \bnt{mean} , (\ty{real}) \bnt{variance}
\end{Verbatim}
The module itself supports load-time input parameters:
\begin{Verbatim}[commandchars=\\\{\}]
    \kw{module load} : "libmodule-randdrive"
        [ , \{ \kw{seed} , (\ty{integer}) \bnt{seed} ]
            | \kw{seed input file name} , " \bnt{seed_input_file_name} " \} ]
        [ , \kw{seed output file name} , " \bnt{seed_output_file_name} " ]
\end{Verbatim}
where the integer \nt{seed} is used to seed the random number generator,
whereas \nt{seed\_input\_file\_name} and \nt{seed\_output\_file\_name}
are used to load/save the random number generator's state
in Boost's internal format.



\section{Template Drive Caller Modules}

\subsection{Module-eu2phi}
This module implements a \htybty{TplDriveCaller}{Vec3} drive caller
that converts three Euler angles into the corresponding Euler vector.

Syntax:
\begin{Verbatim}[commandchars=\\\{\}]
    \kw{eu2phi} ,
        [ \kw{help} , ]
        [ \kw{format} , \{ \kw{euler123} | \kw{euler313} | \kw{euler321} \} , ]
        (\htybty{TplDriveCaller}{Vec3}) \bnt{drive}
\end{Verbatim}
Example:
\begin{verbatim}
    # assuming that file drive 1 provides Euler angles 1, 2 and 3 in channels 1, 2, 3:
    joint: 10, total joint,
        1001,
        1002,
        orientation constraint, active, active, active,
            eu2phi, format, euler123,
                component,
                    file, 1, 1,
                    file, 1, 2,
                    file, 1, 3;
\end{verbatim}


\section{Driver Modules}
Recall that driver modules are invoked as \kw{file} drivers,
whose syntax is
\begin{Verbatim}[commandchars=\\\{\}]
    \bnt{driver_type} ::= \kw{file}

    \bnt{normal_arglist} ::= \bnt{name} [ , \bnt{module_data} ]
\end{Verbatim}



\subsection{Module-HID}
This module provides input from joysticks in the form of a stream,
using the Human Interface Device (HID) standard.
It is the user's responsibility to map the device's output to stream channels.

\begin{Verbatim}[commandchars=\\\{\}]
    \bnt{name} ::= \kw{joystick}

    \bnt{module_data} ::= \bnt{file} ,
        \bnt{number_of_buttons} ,
        \bnt{number_of_linear_controls}
            [ , \kw{scale} , \bnt{scale_factor} [ , ... ] ] ; # \nt{scale_factor}s default to 1.0
\end{Verbatim}
This stream makes available \nt{number\_of\_buttons} + \nt{number\_of\_linear\_controls} channels.
It is assumed that linear controls come after buttons;
\nt{scale\_factor}s apply to linear controls.

The value of buttons is 0 when not pressed, and 1 when pressed.

The value coming from linear controls is (assumed to be) comprised between -\kw{UINT16\_MAX} and \kw{UINT16\_MAX};
it is multiplied by its \nt{scale\_factor} and divided by \kw{UINT16\_MAX}, so that the value provided by the channel
is comprised between -\nt{scale\_factor} and \nt{scale\_factor}.
In some cases, the value coming from linear controls can be comprised between 0 and \kw{UINT16\_MAX};
it is suggested to handle this occurrence, if needed, by means of an additional linear drive caller
before using the value provided by this stream driver.

Example:
\begin{verbatim}
    file: 999, joystick,
        "/dev/input/js0",        # joystick device
        8,                       # number of buttons
        6,                       # number of linear controls
            scale, 1., 10., 100., 256., 1., 1.;
\end{verbatim}
        
Note that HID provide events when they occur, whereas the logic of file drivers
is that of gathering information and making it consistently available through
the solution of a time step.

For buttons, the indication that the button was pressed across two time steps is returned.
If the button was released, or pressed and released multiple times,
only the indication that is was pressed (at least once) is actually returned.

For linear controls, the last measured value across two time steps is returned.





\section{Scalar Function Modules}

\subsection{Module-scalarfunc}
Simple example of run-time loadable user-defined scalar function.



\section{Miscellaneous Modules}

\subsection{Module-flightgear}
\emph{Author: Luca Conti (supported by Google Summer of Code 2017)}

\bigskip

\noindent
This module implements...

It consists of three components:
\begin{itemize}
\item a stream modifier for FlightGear flight dynamics data
\item a stream modifier for FlightGear controls data
\item a customization of the file drive caller to support retrieval of FlightGear specific data
from stream drives (see Section~\ref{sec:DriveCaller:FILE})
\end{itemize}
The stream modifiers are used in conjunction with stream output elements for communication to FlightGear
(see Section~\ref{sec:EL:OUTELEM:STREAM_OUTPUT:STREAMED_OUTPUT}),
and with stream drivers for communication from FlightGear
(see Section~\ref{sec:Stream}).

\subsubsection{Stream Output Element}
\begin{Verbatim}[commandchars=\\\{\}]
    \bnt{user_defined} ::= \bnt{user_defined_type} , 
        \{ \kw{NetFDM} | \kw{NetCtrls} \}
        [ , \kw{print options} ]
        , \bnt{var_name} , \bnt{value}
        [ , ...]

    \bnt{user_defined_type} ::= \kw{flightgear}
\end{Verbatim}
where \bnt{value} is currently either \kw{drive} or \kw{nodedof}, followed by the related arguments
as illustrated in Streamed output (see Sec.~\ref{sec:EL:OUTELEM:STREAM_OUTPUT:STREAMED_OUTPUT}).
The supported values for \bnt{var\_name} are listed below with reference to flight dynamics (\kw{NetFDM})
or controls (\kw{NetCtrls}).

\subsubsection{Stream Drive}
\begin{Verbatim}[commandchars=\\\{\}]
    \bnt{user_defined} ::= \bnt{user_defined_type} ,
        \{ \kw{NetFDM} | \kw{NetCtrls} \}
        [ , \kw{print options} ]

    \bnt{user_defined_type} ::= \kw{flightgear}
\end{Verbatim}

\subsubsection{Flight Dynamics Available Channels}
\begin{itemize}
\item
\end{itemize}


\subsubsection{Controls Available Channels}
\begin{itemize}
\item
\end{itemize}


\subsubsection{File Drive Customization}
\begin{Verbatim}[commandchars=\\\{\}]
    \bnt{user_defined} ::= \bnt{user_defined_type} , \bnt{var_name}

    \bnt{user_defined_type} ::= \kw{flightgear}
\end{Verbatim}
The supported names are those listed above for flight dynamics and controls.
The correct subset is chosen based on the type of stream drive the label refers to,
i.e.\ when the file drive caller points to a stream driver related to flight dynamics (\kw{NetFDM}),
the flight dynamics related values for \kw{var\_name} must be used.
Similarly, the controls related values for \kw{var\_name} must be used when the file drive caller
points to a stream driver related to controls (\kw{NetCtrls}).

\paragraph{Example}
\begin{verbatim}
    # ...
    \begin{drivers}
    # ...
        file: CTRLS, stream,
            name, "CTRLS",
            create, yes,
            port, 9011,
            socket type, udp,
            non blocking,
            flightgear, NetCtrls, print options;
    # ...
    \end{drivers}
    \begin{elements}
    # ...
        stream output: FDM,
            stream name, "FG_FDM",
            create, no,
            port, 9012,
            host, "0.0.0.0",
            socket type, tcp,
            non blocking,
            flightgear, NetFDM, print options,
                longitude, drive, node, AIRCRAFT, structural, string, "X[1]", direct,
                latitude, drive, node, AIRCRAFT, structural, string, "X[2]", direct;
        
        ..., file, CTRLS, flightgear, aileron;                       # use as is
        ..., file, CTRLS, flightgear, throttle_01, amplitude, 100.;  # scale
    \end{elements}
\end{verbatim}



\subsection{Module-octave}
\emph{Author: Reinhard Resch}

\noindent
This module implements support for octave-based user-defined entities, including
drive callers, constitutive laws, scalar functions, and elements.

\subsubsection{General octave flags}
Every GNU Octave based entity supports the following flags:
\begin{Verbatim}[commandchars=\\\{\}]
    \bnt{octave_flags} ::= [ \kw{update octave variables}, \{ \kw{yes} | \kw{no} | (\ty{bool}) \bnt{status} \}, ] \\
        [ \kw{update mbdyn variables}, \{ \kw{yes} | \kw{no} | (\ty{bool}) \bnt{status} \}, ] \\
        [ \kw{update global variables}, \{ \kw{yes} | \kw{no} | (\ty{bool}) \bnt{status} \}, ] \\
        [ \kw{pass data manager}, \{ \kw{yes} | \kw{no} | (\ty{bool}) \bnt{status} \}, ] \\
        [ \kw{embed octave}, \{ \kw{yes} | \kw{no} | (\ty{bool}) \bnt{status} \}, ] \\
        [ \kw{octave search path}, (\ty{string}) \bnt{path1} [ , \ldots ] ]
\end{Verbatim}
\paragraph{Global variables}
If the flag \kw{update octave variables} is enabled, MBDyn's symbol table is copied to the global Octave name space before each function call.
This flag should be used only if the Octave function has to access things like plug in variables which depend on the state of the simulation.
If this flag is not enabled (the default) MBDyn's symbol table is copied only before the first call of any Octave function.
If the flag \kw{update mbdyn variables} is enabled, MBDyn's symbol table is updated by Octave's global variables after each function call.
Only those variables that exist in MBDyn's symbol table are updated.
The flag \kw{update global variables} is a combination of \kw{update octave variables} and \kw{update mbdyn variables}.

\paragraph{Additional arguments}
If the flag \kw{pass data manager} is enabled, a pointer to MBDyn's data manager is passed to the Octave function as the last argument.

\paragraph{Embed octave}
The flag \kw{embed octave} makes it possible to write Octave functions directly inside the MBDyn input file.
This is especially useful for small models. If this flag is enabled, the MBDyn input file where \kw{embed octave} appears will be sourced into Octave before the first function call.
In order to work it is necessary to put all MBDyn specific commands inside a $\#\lbrace$ \ldots $\#\rbrace$ comment, and to put all Octave specific code inside a \#/* \ldots \#*/ comment.

\paragraph{Octave's search path}
Directories which should be appended to Octave's search path should appear after \kw{octave search path}.
This is rather a global option and is not specific to a particular element or drive caller.

\subsubsection{Element}
An Octave element is a full featured user defined MBDyn element written in GNU Octave scripting language.
From Octave's point of view an Octave element is a special class.
\begin{Verbatim}[commandchars=\\\{\}]
    \bnt{elem_type} ::= \kw{user defined}

    \bnt{normal_arglist} ::= \kw{octave} , " \bnt{class\_name} " \\
        [ , \bnt{octave\_flags} ] \\
        [ , \bnt{elem\_data} ]
\end{Verbatim}
All member functions of this class must reside in a directory named ``\texttt{@}\bnt{class\_name}''.
The parent directory of ``\texttt{@}\bnt{class\_name}'' must be in Octave's search path.
Additional Element specific data in \bnt{elem\_data} like node labels,
vectors and rotation matrices may be accessed from within the constructor
of the Octave class.
If the \texttt{octave-ad} package is installed,
the \texttt{D} function can be used to in order to compute
the Jacobian matrix from the residual.

\paragraph{Octave element member functions}
At the moment the following member functions are supported:
\begin{itemize}
\item \verb![elem] = !\bnt{class\_name}\verb!(pMbElem, pDM, HP) !
\item \verb![iRows, iCols] = !\kw{WorkSpaceDim}\verb!(elem) !
\item \verb![iNumDof] = !\kw{iGetNumDof}\verb!(elem) # optional; iNumDof == 0 if missing !
\item \kw{SetValue}\verb!(elem, XCurr, XPrimeCurr) # optional !
\item \verb![f, ridx] = !\kw{AssRes}\verb!(elem, dCoef, XCurr, XPrimeCurr) !
\item \verb![Jac, ridx, cidx, bSparse] = !\kw{AssJac}\verb!(elem, dCoef, XCurr, XPrimeCurr) # optional !
\item \verb![elem] = !\kw{Update}\verb!(elemin, XCurr, XPrimeCurr) # optional !
\item \verb![iRows, iCols] = !\kw{InitialWorkSpaceDim}\verb!(elem) # optional !
\item \verb![iNumDof] = !\kw{iGetInitialNumDof}\verb!(elem) # optional !
\item \kw{SetInitialValue}\verb!(elem, XCurr) # optional !
\item \verb![f, ridx] = !\kw{InitialAssRes}\verb!(elem, XCurr) # optional !
\item \verb![Jac, ridx, cidx, bSparse] = !\kw{InitialAssJac}\verb!(elem, XCurr) # optional !
\item \verb![order] = !\kw{GetDofType}\verb!(elem, i) # optional !
\item \verb![order] = !\kw{GetEqType}\verb!(elem, i) # optional !
\item \verb![elem] = !\kw{AfterPredict}\verb!(elemin, XCurr, XPrimeCurr) # optional !
\item \verb![elem] = !\kw{AfterConvergence}\verb!(elemin, XCurr, XPrimeCurr) # optonal !
\item \verb![iNumPrivData] = !\kw{iGetNumPrivData}\verb!(elem) # optional !
\item \verb![iPrivDataIdx] = !\kw{iGetPrivDataIdx}\verb!(elem, name) # optional !
\item \verb![dPrivData] = !\kw{dGetPrivData}\verb!(elem, i) # optional !
\item \verb![iNumConnectedNodes] = !\kw{iGetNumConnectedNodes}\verb!(elem) # optional !
\item \verb![connectedNodes] = !\kw{GetConnectedNodes}\verb!(elem) # optional !
\item \kw{Output}\verb!(elem, outStream) # optional !
\item \kw{DescribeDof}\verb!(elem, out, prefix, bInitial) # optional !
\item \kw{DescribeEq}\verb!(elem, out, prefix, bInitial) # optional !
\item \kw{Restart}\verb!(elem, out) # optional !
\end{itemize}
Semantic and parameters of these functions are almost the same like in C++. \\
\textbf{TODO}: Describe the meaning of the parameters!

\subsubsection{Drive Caller}
An Octave drive caller could be used as an alternative to string drives or GiNaC drives. 
If the \texttt{octave-ad} package is installed, Octave based drive callers are differentiable by default.
An arbitrary number of additional arguments can be passed to the Octave function \bnt{function\_name} after the \kw{arguments} keyword.
\begin{Verbatim}[commandchars=\\\{\}]
    \bnt{drive_caller} ::= \kw{octave} , " \bnt{function\_name} "
        [ , \bnt{octave\_flags} ] \\
        [ , \kw{arguments}, (\ty{integer}) \bnt{count}, \bnt{arg_1} [ , \ldots , \bnt{arg_n} ] ]
\end{Verbatim}

\subsubsection{Template Drive Caller}
The syntax of a template drive caller is the same like the scalar drive caller. Of course the Octave function must return a matrix or a vector according to the dimension of the drive caller. The template drive caller is also differentiable by default.
\begin{Verbatim}[commandchars=\\\{\}]
    \bnt{tpl_drive_caller} ::= \kw{octave} , " \bnt{function\_name} "
        [ , \bnt{octave\_flags} ] \\
        [ , \kw{arguments}, (\ty{integer}) \bnt{count}, \bnt{arg_1} [ , \ldots , \bnt{arg_n} ] ]
\end{Verbatim}

\subsubsection{Scalar Function}
\begin{Verbatim}[commandchars=\\\{\}]
    \bnt{scalar_function} ::= \kw{octave} , " \bnt{function\_name} "
        [ , \bnt{octave_flags} ] \\
        [ , \kw{arguments}, (\ty{integer}) \bnt{count}, \bnt{arg_1} [ , \ldots , \bnt{arg_n} ] ]
\end{Verbatim}

\subsubsection{Constitutive Law}
Octave constitutive laws are full featured user defined constitutive laws.
Additional constitutive law specific data in \bnt{const\_law\_data} may be accessed from within the constructor of the Octave class.
\begin{Verbatim}[commandchars=\\\{\}]
    \bnt{specific_const_law} ::= \kw{octave} , " \bnt{class\_name} " \\
        [ , \bnt{octave\_flags} ] \\
        \kw{dimension} , \bnt{dimension} \\
        [ , \bnt{const\_law\_data} ]
\end{Verbatim}

\paragraph{Octave constitutive law member functions}
At the moment the following member functions are supported:
\begin{itemize}
\item \verb![cl] = !\bnt{class\_name}\verb!(pDM, HP) !
\item \verb![cl, F, FDE, FDEPrime] = !\kw{Update}\verb!(clin, Eps, EpsPrime) !
\item \verb![constLawType] = !\kw{GetConstLawType}\verb!(cl) !
\end{itemize}
If the \texttt{octave-ad} package is installed, the \texttt{D} function
can be used to compute \texttt{FDE} and \texttt{FDEPrime}
from function \texttt{F}.
Semantic and parameters of these functions are almost the same like in C++. \\
\textbf{TODO}: Describe the meaning of the parameters!

\subsection{Module-tclpgin}
This module implements the Tcl plugin in form of run-time loadable module.
 
\subsection{Module-template}
Loadable element template (deprecated).

\subsection{Module-udunits}
\emph{Author: Pierangelo Masarati}

\noindent
This module implements a namespace called \kw{units}
that provides unit-conversion capabilities
to the mathematical parser, based on the UDUnits library.
The namespace provides only the function \kw{convert},
which is thus invoked as \texttt{units::convert}.
This function's prototype is
\begin{Verbatim}[commandchars=\\\{\}]
    (\ty{real}) \kw{units}::\kw{convert}( (\ty{string}) \bnt{from} , (\ty{string}) \bnt{to} [ , (\ty{real}) \bnt{val} ] )
\end{Verbatim}
where
\begin{itemize}
\item \nt{from} is a string indicating what units to convert from;
\item \nt{to} is a string indicating what units to convert to;
\item \nt{val} is an optional real argument that indicates what value should be converted.
\end{itemize}
When called with just the two mandatory arguments, the function returns the
scale factor between the two units; for example
\begin{Verbatim}[commandchars=\\\{\}]
    units::convert("ft", "m")
\end{Verbatim}
returns 0.3048.

When called with the third optional argument \nt{val} as well, the function returns
the optional argument \nt{val} converted according to the conversion arguments;
for example
\begin{Verbatim}[commandchars=\\\{\}]
    units::convert("ft", "m", 10.)
\end{Verbatim}
returns 3.048, corresponding to
\begin{Verbatim}[commandchars=\\\{\}]
    0.3048 m/ft * 10 ft
\end{Verbatim}

The first form may not be enough, for example, for those conversions
that include an ``intercept''; for example, when converting from degrees 
Celsius to degrees Fahrenheit, the actual conversion would be
\begin{Verbatim}[commandchars=\\\{\}]
    F = 32 + 9 / 5 * C
\end{Verbatim}
In those cases, the conversion fails, unless the third argument 
is specified; for example
\begin{Verbatim}[commandchars=\\\{\}]
    units::convert("Celsius", "Fahrenheit")
\end{Verbatim}
would fail, while
\begin{Verbatim}[commandchars=\\\{\}]
    units::convert("Celsius", "Fahrenheit", 0.)
\end{Verbatim}
would return 32.

This module requires UNIDATA's \texttt{libudunits}; get it from
\begin{center}
\url{http://www.unidata.ucar.edu/software/udunits/}.
\end{center}
Some Linux distributions provide it packaged;
for example, recent Ubuntu releases provide a library \texttt{libudunits2};
to use it, tweak the configuration variables
in \texttt{modules/module-udunits/Makefile.inc}.



